---
title: "chapter 3"
author: "Imani Russell"
date: "4/21/2021"
output: html_document
---

# 3.3 Case study 1B: Monocapr life cycle properties and events

Use the Oenothera IBM, but set the probability of recruitment ($p_r$) so that $\lambda=1$
- $\lambda=1$ means we don't need to discount by population size 
    * not exactly sure what this means, says like in Soay sheep example, revisit ****this***

# read in
1) Monocarp Demog Funs.R <- demographic function that describes how size influences rate; functions that describe how size influences rate
2) Monocapr Simulate IBM.R <- simulates IBM
3) Monocarp Events Calculations.R <- implements various event calculations

With monocarps, reproduction is fatal and there are 2 ways to die.

We want to test the various calculations implemented in Monocarp Events Calculations.R <- Use the true parameter values to define the IPM
We want to calculate various metrics stratified by age <- Collect a large sample of individual fates

We will need survival and reproduction iteration matrices
- already constructed IPM using mk_K(nBigMatrix, m.par.true, L, U)
- store iteration matrices in P, F
- define $\texttt{e <- matrix(1, nrow=1, ncol=nBigMatrix)}$ <- use this for summing down the columns of matrices
- define $\texttt{offspring.prob <- h * c_0z1(meshpts, m.par)}$ <- probability distributionof offspring sizes, which we will use as the initial cohort $c(z)$

## 3.3.1 Population Growth
$\lambda$ deals with changes in population size from 1 time step to the next
$R_0$ deals with changes in population size 1 generation to the next
Both can be calculated as eigenvalues of the appropriate kernel (**which is?**)

```{r review from Section.....}
mk_K <- function(m, m.par, L, U) {
	# mesh points 
	h <- (U - L)/m
	meshpts <- L + ((1:m) - 1/2) * h
	P <- h * (outer(meshpts, meshpts, P_z1z, m.par = m.par))
	F <- h * (outer(meshpts, meshpts, F_z1z, m.par = m.par))
	K <- P + F
	return(list(K = K, meshpts = meshpts, P = P, F = F))
}
```

Calculate $\lambda$
```{r lambda}
# construct iteration matrix
IPM.true <- mk_K (nBigMatrix, m.par.true, -3.5, 5.5)

# get the eigenvalues
lambda0 <- Re (eigen (IPM.true$K, only.values = TRUE)$values[1]) #only.values = TRUEspecifies to only calculate eigenvalues (not eigenvectors)
```

Calculate $R_0$
```{r}
# calculate fundamental matrix
N <- solve (diag (nBigMatrix) - P) 
# nBigMatrix creates ID matrix (I)
# P = survival iteration matrix
# solve inverts (I-P) matrix
```

The kernel $R=FN$ projects the population from 1 generation to the next and $R_0$ is the dominant eigenvalue
```{r}
R <- F * N
R0 <- abs (eigen (R)$values[1])

cat ("R0=", R0, "\n");
```

IN the IPM, offspring size in independent of parent size, so we can calculate $R_0$ directly by averaging per-capita fecundity with respect to the size at birth **Box 3.1**
```{r calculate R0}
R0 <- sum ((e %*% R) * offspring.prob)

cat ("R0=", R0, "\n");
```